use io::*;
use std::*;

struct Partial {
    len: usize,
    center_r_idx: usize
}

impl Partial {
    fn from_str(string :&str) -> Partial {
        let len = string.len();
        let mut idx = 0;
        for i in 0..(len - 1) {
            if string.chars().nth(i + 1).unwrap() == 'L' {
                idx = i;
                break;
            }
        }
        Partial {
            len,
            center_r_idx: idx       
        }
    }
    fn get_r(&self) -> usize {
        // RLの部分の内、Rに最終的にいる人数
        self.len / 2 + (self.center_r_idx + 1) % 2 * self.len % 2
    }
    fn get_l(&self) -> usize {
        // RLの部分の内、Lに最終的にいる人数
        self.len / 2 + (self.center_r_idx % 2) * (self.len % 2)
    }
    fn get_string(&self) -> String {
        let mut v: Vec<&str> = vec![];
        v.append(&mut vec!["0"].repeat(self.center_r_idx));
        let (r, l) = (self.get_r().to_string(), self.get_l().to_string());
        v.append(&mut vec![&r, &l]);
        v.append(&mut vec!["0"].repeat(self.len - self.center_r_idx - 2));
        v.join(" ")
    }
}

fn split(s: String) -> Vec<Partial> {
    let mut v = vec![];
    let chars: Vec<char> = s.chars().collect();
    let mut pre_idx = 0;
    let pat = ['L', 'R'];
    for i in 2..chars.len() {
        if chars[(i - 1)..(i + 1)] == pat {
            v.push(Partial::from_str(&chars[pre_idx..i].iter().collect::<String>()));
            pre_idx = i;
        }
    }
    v.push(Partial::from_str(&chars[pre_idx..chars.len()].iter().collect::<String>()));
    v
}

fn concat(pv: Vec<Partial>) -> String {
    pv.iter().map(|p| p.get_string()).collect::<Vec<String>>().join(" ")
}

fn solve(S: String) {
    // RLとなっている部分のRからの距離を測る
    // R...RL...Lを一つの単位として考える
    let pv = split(S);
    let s = concat(pv);
    println!("{}", s);
}

// Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
fn main() {
    let con = read_string();
    let mut scanner = Scanner::new(&con);
    let mut S: String;
    S = scanner.next();
    // In order to avoid potential stack overflow, spawn a new thread.
    let stack_size = 104_857_600; // 100 MB
    let thd = std::thread::Builder::new().stack_size(stack_size);
    thd.spawn(move || solve(S)).unwrap().join().unwrap();
}

pub mod io {
    use std;
    use std::str::FromStr;

    pub struct Scanner<'a> {
        iter: std::str::SplitWhitespace<'a>,
    }

    impl<'a> Scanner<'a> {
        pub fn new(s: &'a str) -> Scanner<'a> {
            Scanner {
                iter: s.split_whitespace(),
            }
        }

        pub fn next<T: FromStr>(&mut self) -> T {
            let s = self.iter.next().unwrap();
            if let Ok(v) = s.parse::<T>() {
                v
            } else {
                panic!("Parse error")
            }
        }

        pub fn next_vec_len<T: FromStr>(&mut self) -> Vec<T> {
            let n: usize = self.next();
            self.next_vec(n)
        }

        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {
            (0..n).map(|_| self.next()).collect()
        }
    }

    pub fn read_string() -> String {
        use std::io::Read;

        let mut s = String::new();
        std::io::stdin().read_to_string(&mut s).unwrap();
        s
    }

    pub fn read_line() -> String {
        let mut s = String::new();
        std::io::stdin().read_line(&mut s).unwrap();
        s.trim_right().to_owned()
    }
}
